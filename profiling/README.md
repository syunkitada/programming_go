# Profiling

## ベンチマーク

```
# -benchmemを付けると、ヒープ割り当ての回数が表示される（平均が表示される）
$ cd [directory]
$ go test -bench . -benchmem

$ go test -bench . ./[directory]/[filename].go -benchmem
```

## エスケープ分析

- Go コンパイラは、スタック割り当てとヒープ割り当てのどちらを行うかをエスケープ分析によって選択する
- スタックはコストが安く、ヒープはコストが高い
- エスケープ分析の結果は以下で確認できる
  - escapes to heap と表示されたら、heap が利用される
  - does not escape と表示されたら、stack が利用される

```
# 以下はescapeするかどうかが表示される
$ go build -gcflags '-m'
# github.com/syunkitada/go-samples/profiling/sample
./main.go:7:13: inlining call to fmt.Println
./main.go:7:13: x escapes to heap
./main.go:7:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape

# 以下はなぜescapeするかの理由まで表示される
$ go build -gcflags '-m -m'
# github.com/syunkitada/go-samples/profiling/sample
./main.go:5:6: cannot inline main: function too complex: cost 81 exceeds budget 80
./main.go:7:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = <N>; var fmt..autotmp_4 error; fmt..autotmp_4 = <N>; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 }
./main.go:7:13: x escapes to heap:
./main.go:7:13:   flow: ~arg0 = &{storage for x}:
./main.go:7:13:     from x (spill) at ./main.go:7:13
./main.go:7:13:     from ~arg0 = <N> (assign-pair) at ./main.go:7:13
./main.go:7:13:   flow: {storage for []interface {} literal} = ~arg0:
./main.go:7:13:     from []interface {} literal (slice-literal-element) at ./main.go:7:13
./main.go:7:13:   flow: fmt.a = &{storage for []interface {} literal}:
./main.go:7:13:     from []interface {} literal (spill) at ./main.go:7:13
./main.go:7:13:     from fmt.a = []interface {} literal (assign) at ./main.go:7:13
./main.go:7:13:   flow: {heap} = *fmt.a:
./main.go:7:13:     from fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) (call parameter) at ./main.go:7:13
./main.go:7:13: x escapes to heap
./main.go:7:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
```

## 参考

- [Profiling Go Programs](https://go.dev/blog/pprof)
- [Allocation efficiency in high-performance Go services](https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/)
  - [go で書いたコードがヒープ割り当てになるかを確認する方法](https://hnakamur.github.io/blog/2018/01/30/go-heap-allocations/)
    - Allocation efficiency in high-performance Go services のメモ書き記事
