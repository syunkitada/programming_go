# FOR UPDATE を Insert のために使ってみる

- Insert しようとしてるテーブルに対して SELECT ... FOR UPDATE を実行してロックする(トランザクション 1)
  - このときレコードがあれば排他ロックがかかるが、ない場合はロックがかからない
  - しかし、SELECT した id に index が設定されている場合は、ネクストキーロック(ギャップロック)として排他ロックがかかる
  - ギャップロックがかかると他のトランザクションによるギャップへの挿入が停止される
- また別トランザクションでも同様に SELECT ... FOR UPDATE を実行してロックする(トランザクション 2)
  - このときトランザクション 1 と同様にギャップロックがかかる
- トランザクション 1 が INSERT しようとすると、トランザクション 2 でギャップロックを取られてるので待たされる
- またトランザクション 2 も同様にトランザクション 1 でギャップロックを取られているのでまたされる
- このように複数のトランザクションがギャップロックを取るとデッドロックとなる
- 対処法
  - 片方のトランザクションがデッドロックで失敗すると、一方のトランザクションは成功するので、失敗した側は再試行すればよい
  - 失敗した側は以下のようなログを出す
    - Deadlock found when trying to get lock; try restarting transaction
- 参考
  - [「トランザクション張っておけば大丈夫」と思ってませんか？ バグの温床になる、よくある実装パターン](https://zenn.dev/tockn/articles/4268398c8ec9a9)
